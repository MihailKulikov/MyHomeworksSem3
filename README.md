# SPBU homework

Here's homework from programming lessons. (sem 3)

## Navigation menu

[SPBU homework](https://github.com/MihailKulikov/MyHomeworksSem3) |
----------- |
[Homework №1](https://github.com/MihailKulikov/MyHomeworksSem3#homework-1) |
[Homework №2](https://github.com/MihailKulikov/MyHomeworksSem3#homework-2) |

## Homework №1 
[Решение](https://github.com/MihailKulikov/MyHomeworksSem3/tree/main/sem3/hw1.1)

Одна из самых полезных и вместе с тем хорошо параллелящихся задач — умножение матриц. Это часто используется не только в научных расчётах, но и при практически любой работе с графикой, особенно трёхмерной. Фактически, современные видеокарты — это специализированные вычислители, умеющие умножать матрицы (в частности, вектора на матрицы) очень эффективно за счёт большого количества вычислительных узлов (до сотен в современных выделенных видеокартах). Естественно, параллельно. Вам надо попробовать поумножать матрицы с помощью обычного многоядерного процессора.
Требуется реализовать параллельное умножение для плотных матриц. На входе программа получает два файла с матрицами (не обязательно квадратными), на выходе должен получиться файл, содержащий матрицу — их произведение. Сравнить скорость работы с последовательным вариантом в зависимости от размеров матриц. Попробовать получить возможно большее ускорение.

## Homework №2
[Решение](https://github.com/MihailKulikov/MyHomeworksSem3/tree/main/sem3/hw2.1)

Реализовать следующий интерфейс, представляющий ленивое вычисление:
```
public interface ILazy<T> {
        T Get();
}
```
Объект Lazy создаётся на основе вычисления (представляемого объектом Func<T>)
  - Первый вызов Get() вызывает вычисление и возвращает результат
  - Повторные вызовы Get() возвращают тот же объект, что и первый вызов
  - Вычисление должно запускаться не более одного раза
  
  Создавать объекты надо не вручную, а с помощью класса LazyFactory, который должен иметь два метода с сигнатурами наподобие
  `public static Lazy<T> Create...Lazy<T>(Func<T> supplier)`
  возвращающих две разные реализации ILazy<T>:
  - Простая версия с гарантией корректной работы в однопоточном режиме (без синхронизации)
  - Гарантия корректной работы в многопоточном режиме
    - При этом она должна по возможности минимизировать число необходимых синхронизаций (если значение уже вычислено, не должно быть блокировок)
  - supplier вправе вернуть null
  - Библиотечным Lazy пользоваться, естественно, нельзя
  
Нужно:
  - CI, на котором проходят ваши тесты
  - Тесты
    - Однопоточные, на разные хорошие и плохие случаи
    - Многопоточные, на наличие гонок
