# SPBU homework

Here's homework from programming lessons. (sem 3)

## Navigation menu

[SPBU homework](https://github.com/MihailKulikov/MyHomeworksSem3) |
----------- |
[Homework №1](https://github.com/MihailKulikov/MyHomeworksSem3#homework-1) |
[Homework №2](https://github.com/MihailKulikov/MyHomeworksSem3#homework-2) |
[Homework №3](https://github.com/MihailKulikov/MyHomeworksSem3#homework-3) |
[Homework №4](https://github.com/MihailKulikov/MyHomeworksSem3#homework-4) |

## Homework №1 
[Решение](https://github.com/MihailKulikov/MyHomeworksSem3/tree/main/sem3/hw1.1)

Одна из самых полезных и вместе с тем хорошо параллелящихся задач — умножение матриц. Это часто используется не только в научных расчётах, но и при практически любой работе с графикой, особенно трёхмерной. Фактически, современные видеокарты — это специализированные вычислители, умеющие умножать матрицы (в частности, вектора на матрицы) очень эффективно за счёт большого количества вычислительных узлов (до сотен в современных выделенных видеокартах). Естественно, параллельно. Вам надо попробовать поумножать матрицы с помощью обычного многоядерного процессора.
Требуется реализовать параллельное умножение для плотных матриц. На входе программа получает два файла с матрицами (не обязательно квадратными), на выходе должен получиться файл, содержащий матрицу — их произведение. Сравнить скорость работы с последовательным вариантом в зависимости от размеров матриц. Попробовать получить возможно большее ускорение.

## Homework №2
[Решение](https://github.com/MihailKulikov/MyHomeworksSem3/tree/main/sem3/hw2.1)

Реализовать следующий интерфейс, представляющий ленивое вычисление:
```csharp
public interface ILazy<T>
{
        T Get();
}
```
Объект Lazy создаётся на основе вычисления (представляемого объектом Func<T>)
  - Первый вызов Get() вызывает вычисление и возвращает результат
  - Повторные вызовы Get() возвращают тот же объект, что и первый вызов
  - Вычисление должно запускаться не более одного раза
  
  Создавать объекты надо не вручную, а с помощью класса LazyFactory, который должен иметь два метода с сигнатурами наподобие
  `public static Lazy<T> Create...Lazy<T>(Func<T> supplier)`
  возвращающих две разные реализации ILazy<T>:
  - Простая версия с гарантией корректной работы в однопоточном режиме (без синхронизации)
  - Гарантия корректной работы в многопоточном режиме
    - При этом она должна по возможности минимизировать число необходимых синхронизаций (если значение уже вычислено, не должно быть блокировок)
  - supplier вправе вернуть null
  - Библиотечным Lazy пользоваться, естественно, нельзя
  
Нужно:
  - CI, на котором проходят ваши тесты
  - Тесты
    - Однопоточные, на разные хорошие и плохие случаи
    - Многопоточные, на наличие гонок
    
## Homework №3
[Решение](https://github.com/MihailKulikov/MyHomeworksSem3/tree/main/sem3/hw3.1)

- При создании объекта MyThreadPool в нем должно начать работу n потоков
- У каждого потока есть два состояния: ожидание задачи / выполнение задачи
- Задача — вычисление некоторого значения, описывается в виде Func<TResult>
- При добавлении задачи, если в пуле есть ожидающий поток, то он должен приступить к ее исполнению. Иначе задача будет ожидать исполнения, пока не освободится какой-нибудь поток
- Задачи, принятые к исполнению, представлены в виде объектов интерфейса IMyTask<TResult>
- Метод Shutdown должен завершить работу потоков. Завершение работы коллаборативное, с использованием CancellationToken — уже запущенные задачи не прерываются, но новые задачи не принимаются на исполнение потоками из пула.
  - Возможны два варианта решения — дать всем задачам, которые уже попали в очередь, досчитаться, либо выбросить исключение во все ожидающие завершения задачи потоки
  - Shutdown не должен возвращать управление, пока все потоки не остановились
- IMyTask 
  - Свойство IsCompleted возвращает true, если задача выполнена 
  - Свойство Result возвращает результат выполнения задачи   
  - В случае, если соответствующая задаче функция завершилась с исключением, этот метод должен завершиться с исключением AggregateException, содержащим внутри себя исключение, вызвавшее проблему
  - Если результат еще не вычислен, метод ожидает его и возвращает полученное значение, блокируя вызвавший его поток
  - Метод ContinueWith — принимает объект типа Func<TResult, TNewResult>, который может быть применен к результату данной задачи X и возвращает новую задачу Y, принятую к исполнению
  - Новая задача будет исполнена не ранее, чем завершится исходная
  - В качестве аргумента объекту Func будет передан результат исходной задачи, и все Y должны исполняться на общих основаниях (т.е. должны разделяться между потоками пула)
  - Метод ContinueWith может быть вызван несколько раз
  - Метод ContinueWith не должен блокировать работу потока, если результат задачи X ещё не вычислен
ContinueWith должен быть согласован с Shutdown — принятая как ContinueWith задача должна либо досчитаться, либо бросить исключение ожидающему её потоку.
При этом:
- В данной работе запрещено использование TPL, PLINQ и библиотечных классов Task и ThreadPool.
- Все интерфейсные методы должны быть потокобезопасны
- Для каждого базового сценария использования должен быть написан несложный тест
- Также должен быть написан тест, проверяющий, что в пуле действительно не менее n потоков

## Homework №4
[Решение](https://github.com/MihailKulikov/MyHomeworksSem3/tree/main/sem3/hw4.1)

Требуется реализовать сервер, обрабатывающий два запроса.
- List — листинг файлов в директории на сервере
- Get — скачивание файла с сервера
И клиент, позволяющий исполнять указанные запросы.

List, формат запроса:
- 1 <path: String>
- path — путь к директории относительно того места, где запущен сервер
- Например, "1 ./Test/Files

Формат ответа:
- <size: Int> (<name: String> <isDir: Boolean>)*
- size — количество файлов и папок в директории
- name — название файла или папки
- isDir — флаг, принимающий значение "true" для директорий
- Например, "2 ./Test/files/file1.txt false ./Test/files/directory true"
- Если директории не существует, сервер посылает ответ с size = -1

Get, формат запроса:

- 2 <path: String>
- path — путь к файлу относительно того места, где запущен сервер

Формат ответа: 
- <size: Long> <content: Bytes>
- size — размер файла
- content — его содержимое
- Если файла не существует, сервер посылает ответ с size = -1

Сервер должен иметь возможность обслуживать несколько клиентов одновременно (например, в ситуации, когда три клиента одновременно скачивают большой файл).

Обратите внимание на строгое следование протоколу. Сервер любого правильного решения должен уметь взаимодействовать с клиентом любого другого правильного решения.
